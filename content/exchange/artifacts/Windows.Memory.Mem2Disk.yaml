name: Windows.Memory.Mem2Disk
author: Lautaro Lecumberry, Dr. Michael Denzel
description: |
    This artifact compares executables in memory (RAM) with those
    on hard disk. This way, RAM injections are detected. This rarely
    happens legitimately and is mostly used by malware.
    This check is executed without dumping the memory and works live
    on the target system(s).
    See also https://github.com/lautarolecumberry/DetectingFilelessMalware

parameters:
- name: IgnoreOneByteOffsets
  description: Relative Virtual Adresses (RVA) cause an offset in the code in memory of a process.
               This is the case when the field BaseOfData is set to 0x8000. It creates false
               positives and is fairly safe to ignore (1-byte injections are really hard).
  default: True
  type: bool
- name: UploadFindings
  description: Upload all executables where code in memory does not match code on disk. This
               can potentially generate a lot of traffic. Dry-run before enabling this option.
  default: False
  type: bool
- name: ProcessNameFilter
  type: regex
  default: .
- name: ModuleRegEx
  type: regex
  description: Filter for modules to check.
  default: "(KERNELBASE|ntdll).dll|.exe"

precondition: SELECT OS From info() where OS = 'windows'

export: |
  -- These functions help to resolve the Kernel Device Filenames
  -- into a regular filename with drive letter.
  LET DriveReplaceLookup <= SELECT
      split(sep_string="\\", string=Name)[-1] AS Drive,
      upcase(string=SymlinkTarget) AS Target,
      len(list=SymlinkTarget) AS Len
    FROM winobj()
    WHERE Name =~ "^\\\\GLOBAL\\?\\?\\\\.:"

  LET _DriveReplace(Path) = SELECT Drive + Path[Len:] AS ResolvedPath
    FROM DriveReplaceLookup
    WHERE upcase(string=Path[:Len]) = Target

  LET DriveReplace(Path) = _DriveReplace(Path=Path)[0].ResolvedPath ||
      Path

sources:
- query: |
    -- get all processes
    LET GetPids = SELECT Pid,
                         Name,
                         Username,
                         if(condition=IsWow64, then=4, else=8) AS IntSize
      FROM pslist()
      WHERE Name =~ ProcessNameFilter
    
    -- get all memory pages for a certain pid
    LET InfoFromVad(Pid) = SELECT Address,
                                  Size,
                                  DriveReplace(Path=MappingName) AS Path
      FROM vad(pid=Pid)
      WHERE MappingName
       AND Protection =~ "xr-"
            AND MappingName =~ ModuleRegEx
      LIMIT 1
    
    LET GetTextSegment(Path) = filter(condition="x=>x.Name = '.text'",
                                      list=parse_pe(file=Path).Sections)[0]
    
    -- parse the executable (PE) from memory (specifically, the text segment)
    LET GetMetadata(Pid) = SELECT Path,
                                  str(str=Pid) AS PidFilename,
                                  Address,
                                  GetTextSegment(Path=Path) AS TextSegmentData
      FROM InfoFromVad(Pid=Pid)
      WHERE Address != 0
      AND TextSegmentData.FileOffset
    
    LET Hex(X) = format(format="%#x", args=X)

    LET Int64(X) = parse_binary(profile="",
                            struct="int64",
                            accessor="data",
                            filename=X)
    
    -- read the executable from memory and hard disk
    LET GetContent(Pid, Name) = SELECT
        *, Name,
        Address AS MemAddress,
        Hex(X=Address - TextSegmentData.VMA) AS ASLR, 
        read_file(accessor="process",
                  offset=Address,
                  filename=PidFilename,
                  length=TextSegmentData.Size) AS MemoryData,
        TextSegmentData.FileOffset AS DiskAddress,
        TextSegmentData.Size AS SegmentSize,
        read_file(accessor="file",
                  offset=TextSegmentData.FileOffset,
                  filename=Path,
                  length=TextSegmentData.Size) AS DiskData
      FROM GetMetadata(Pid=Pid)
      WHERE MemoryData
      AND log(dedup=-1,
              message="Inspecting Pid %v (%v): %#x-%#x vs %#x-%#x",
              args=[Pid, Name, Address, Address + SegmentSize,
                DiskAddress, DiskAddress + SegmentSize])

    -- Filter out not needed comparisons early
    LET FilterContent(Pid, Name) = SELECT *, MemoryData = DiskData AS Comparison
      FROM GetContent(Pid=Pid, Name=Name)
      WHERE NOT Comparison

    LET PAGESIZE <= 1024 * 1024

    LET _CompareRegions(Base, X, Y, PAGESIZE) = SELECT
        _value + Base AS Offset,
        X[_value:(_value + PAGESIZE)] AS XInt,
        Y[_value:(_value + PAGESIZE)] AS YInt
      FROM range(end=len(list=X), step=PAGESIZE)
      WHERE XInt != YInt

    LET CompareRegions(X, Y, IntSize) = SELECT
        Offset,
        Hex(X=XInt) AS X,
        Hex(X=YInt) AS Y,
        Hex(X=Int64(X=XInt) - Int64(X=YInt)) AS Difference
      FROM foreach(row={
        SELECT *
        FROM _CompareRegions(Base=0, X=X, Y=Y, PAGESIZE=PAGESIZE)
      },
                  query={
        SELECT *
        FROM foreach(row={
        SELECT *
        FROM _CompareRegions(Base=Offset, X=XInt, Y=YInt, PAGESIZE=4096)
      },
                    query={
        SELECT *
        FROM _CompareRegions(Base=Offset, X=XInt, Y=YInt, PAGESIZE=IntSize)
      })
      })
      LIMIT 500

    LET CompareUniqueRegions(X, Y, IntSize, ASLR) = SELECT *
      FROM CompareRegions(X=X, Y=Y, IntSize=IntSize)
      WHERE Difference != ASLR
      GROUP BY Difference

    -- compare the executable from memory and hard disk
    -- only print the ones where they do not match
    LET Compare(Pid, Name, IntSize) = if(
        condition=log(message="Comparing process %v", args=Pid)
        AND IgnoreOneByteOffsets,
        then={
        SELECT Pid,
              Name,
              ASLR,
              IntSize,
              PidFilename,
              Path,
              {
        SELECT Offset,
              X AS MemoryValue,
              Y AS DiskValue,
              Difference,
              Hex(X=ASLR) AS ASLR
        FROM CompareUniqueRegions(X=MemoryData, Y=DiskData, IntSize=IntSize, ASLR=ASLR)
        } AS Differences,
              MemAddress,
              DiskAddress,
              SegmentSize
        FROM FilterContent(Pid=Pid, Name=Name)
        WHERE NOT OneByteOffset
      },
        else={
        SELECT Pid,
              Name,
              ASLR,
              IntSize,
              PidFilename,
              Path,
              MemAddress,
              DiskAddress,
              SegmentSize
        FROM FilterContent(Pid=Pid, Name=Name)
      })

    -- compare with uploading the suspicious executables
    LET CompareAndUpload(Pid, Name, IntSize) = SELECT
        Pid,
        Path,
        Hex(X=MemAddress) AS MemAddress,
        Hex(X=DiskAddress) AS DiskAddress,
        Hex(X=SegmentSize) AS SegmentSize,
        upload(
          file=pathspec(DelegateAccessor="process",
                        DelegatePath=PidFilename,
                        Path=[dict(Offset=MemAddress, Length=SegmentSize), ]),
          name=pathspec(parse=format(format="%s.%d.mem", args=[Path, Pid]),
                        path_type="windows"),
          accessor="sparse") AS UploadMem,
        upload(
          file=pathspec(DelegateAccessor="file",
                        DelegatePath=Path,
                        Path=[dict(Offset=DiskAddress, Length=SegmentSize), ]),
          name=pathspec(parse=format(format="%s.%d.disk", args=[Path, Pid]),
                        path_type="windows"),
          accessor="sparse") AS UploadDisk
      FROM Compare(Pid=Pid, Name=Name, IntSize=IntSize)

    -- for every process, evaluate the memory-harddisk-comparison
    SELECT *
    FROM foreach(row=GetPids,
                workers=20,
                query={
        SELECT *
        FROM if(condition=UploadFindings,
                then={
        SELECT *
        FROM CompareAndUpload(Pid=Pid, Name=Name, IntSize=IntSize)
      },
                else={
        SELECT *
        FROM Compare(Pid=Pid, Name=Name, IntSize=IntSize)
      })
      })
