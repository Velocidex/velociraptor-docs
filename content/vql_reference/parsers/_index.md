---
title: Parsers
weight: 30
linktitle: Parsers
index: true
no_edit: true
no_children: true
---

Many Velociraptor artifacts rely on specialized parsing of file
formats. This page outlines all the plugins and functions designed
to allow the client to parse information for various files.

Simple file formats may be parsed using regular expressions and
other generic rules. However some specialized file formats have
dedicated parsers. These dedicated parsers are exported into VQL
plugins so their results may be used in further queries.
|Plugin/Function|<span class='vql_type'>Type</span>|Description|
|-|-|-|
|[grok](grok)|<span class='vql_type'>Function</span>|Parse a string using a Grok expression|
|[olevba](olevba)|<span class='vql_type'>Plugin</span>|Extracts VBA Macros from Office documents|
|[parse_auditd](parse_auditd)|<span class='vql_type'>Plugin</span>|Parse log files generated by auditd|
|[parse_binary](parse_binary)|<span class='vql_type'>Function</span>|Parse a binary file into a data structure using a profile|
|[parse_csv](parse_csv)|<span class='vql_type'>Plugin</span>|Parses events from a CSV file|
|[parse_ese](parse_ese)|<span class='vql_type'>Plugin</span>|Opens an ESE file and dump a table|
|[parse_ese_catalog](parse_ese_catalog)|<span class='vql_type'>Plugin</span>|Opens an ESE file and dump the schema|
|[parse_evtx](parse_evtx)|<span class='vql_type'>Plugin</span>|Parses events from an EVTX file|
|[parse_float](parse_float)|<span class='vql_type'>Function</span>|Convert a string to a float|
|[parse_json](parse_json)|<span class='vql_type'>Function</span>|Parse a JSON string into an object|
|[parse_json_array](parse_json_array)|<span class='vql_type'>Function</span>|Parse a JSON string into an array|
|[parse_json_array](parse_json_array)|<span class='vql_type'>Plugin</span>|Parses events from a line oriented json file|
|[parse_jsonl](parse_jsonl)|<span class='vql_type'>Plugin</span>|Parses a line oriented json file|
|[parse_lines](parse_lines)|<span class='vql_type'>Plugin</span>|Parse a file separated into lines|
|[parse_mft](parse_mft)|<span class='vql_type'>Plugin</span>|Scan the $MFT from an NTFS volume|
|[parse_ntfs](parse_ntfs)|<span class='vql_type'>Function</span>|Parse specific inodes from an NTFS image file or the raw device|
|[parse_ntfs_i30](parse_ntfs_i30)|<span class='vql_type'>Plugin</span>|Scan the $I30 stream from an NTFS MFT entry|
|[parse_ntfs_ranges](parse_ntfs_ranges)|<span class='vql_type'>Plugin</span>|Show the run ranges for an NTFS stream|
|[parse_pe](parse_pe)|<span class='vql_type'>Function</span>|Parse a PE file|
|[parse_pkcs7](parse_pkcs7)|<span class='vql_type'>Function</span>|Parse a DER encoded pkcs7 string into an object|
|[parse_records_with_regex](parse_records_with_regex)|<span class='vql_type'>Plugin</span>|Parses a file with a set of regexp and yields matches as records|
|[parse_recyclebin](parse_recyclebin)|<span class='vql_type'>Plugin</span>|Parses a $I file found in the $Recycle|
|[parse_string_with_regex](parse_string_with_regex)|<span class='vql_type'>Function</span>|Parse a string with a set of regex and extract fields|
|[parse_usn](parse_usn)|<span class='vql_type'>Plugin</span>|Parse the USN journal from a device, image file or USN file|
|[parse_x509](parse_x509)|<span class='vql_type'>Function</span>|Parse a DER encoded x509 string into an object|
|[parse_xml](parse_xml)|<span class='vql_type'>Function</span>|Parse an XML document into a dict like object|
|[parse_yaml](parse_yaml)|<span class='vql_type'>Function</span>|Parse yaml into an object|
|[plist](plist)|<span class='vql_type'>Function</span>|Parse plist file|
|[plist](plist)|<span class='vql_type'>Plugin</span>|Parses a plist file|
|[prefetch](prefetch)|<span class='vql_type'>Plugin</span>|Parses a prefetch file|
|[regex_replace](regex_replace)|<span class='vql_type'>Function</span>|Search and replace a string with a regexp|
|[rot13](rot13)|<span class='vql_type'>Function</span>|Apply rot13 deobfuscation to the string|
|[split_records](split_records)|<span class='vql_type'>Plugin</span>|Parses files by splitting lines into records|
|[sqlite](sqlite)|<span class='vql_type'>Plugin</span>|Opens an SQLite file and run a query against it|
|[starl](starl)|<span class='vql_type'>Function</span>|Compile a starlark code block - returns a module usable in VQL|
|[xor](xor)|<span class='vql_type'>Function</span>|Apply xor to the string and key|
